## `Rc<T>`, reference hisoblangan Smart Pointer

Ko‘p hollarda, ownership ochiq, ya’ni tushunarli holda bo’ladi: sizga qaysi o‘zgaruvchi qaysi berilgan qiymatga egalik qilishini aniq bilasiz. Ammo, ayrim hollarda bitta qiymat ko‘p egalarga ega bo‘lishi mumkin. Masalan, grafik ma’lumotlar tuzilmasida (data structures), bir nechta edgelar bitta nodeni point qilishi mumkin, vas shu node unga point qilingan barcha edgelar tomonidan egalik qilinadi. Nodega edgelar point qilinmagungacha, shuningdek egalari bo‘lmagungacha tozalanishi mumkin emas. 

Rustning refenceni hisoblovchi Rc<T> turini ishlatishda siz bir nechta ownershipni aniq qilib yoqishingiz kerak. Qiymatni ishlatilib turganligi yoki ishlamay turganligini aniqlash uchun Rc<T> qiymatga ketayotgan refencelar sonini kuzatib boradi. Agar qiymatda nol (zero) referencelar bo‘lsa, hech qanay reference lar bekor bo‘lmasidan qiymat tozalanishi mumkin.

`Rc<T>` ni zaldagi televizor sifatida tasavvur qiling. Agar bir kishi televizor ko‘rish uchun xonaga kirsa, u televizorni yoqadi. Boshqalar esa shunchaki xonaga kirib tomosha qilsalar bo‘ladi. Xonadan oxirgi odam chiqib ketayotganda, ular televizorni o‘chirib ketishadi chunki televizor boshqa ishlatilmaydi. Agar bir kishi boshqalar televizorni tomosha qilib o‘tirganida o‘chirsa boshqalar uchun g‘alati bo‘lishi mumkin.

Biz `Rc<T>`ni ma’lumotni heapda dasturning ko‘p qismlarini o‘qishi uchun ajratishni hohlasaganimizda foydalanamiz va biz kompilyatsiya vaqti qaysi qism ma’lumotini oxirgi foydalanishni yakunlaganini bila olmaymiz. Agar biz ma’lumotni qaysi qismi oxirida to‘xtashini bilganimizda, biz shu qismni ma’lumotni egasi sifatida tayinlar edik va kompilyatsiya vaqtida qo‘llaniladigan oddiy egalik (ownership) qoidalari kuchga kirar edi.

Shuni yodda tutish kerakki `Rc<T>` yakka-thread holatlardagina ishlatiladi. Biz 16-bo‘limda parralellik haqida suhlashganimizda, biz ko‘p threadli dasturlarda referenceni hisoblashni qanday qilishni o‘rganamiz. 

### `Rc<T>`ni Ma'lumotni Ulashish uchun ishlatish

Keling kamchiligi bor bo‘lgan 15-5 ro‘yxat misolimizga qaytaylik. Esingizda bo‘lsa biz `Box<T>`ni ishlatishni ko‘rsatib o‘tgan edik. Bu safar, biz 2ta ro‘yxat ham egalikni (ownership) 3-ro‘yxat bilan ulashadigan ro‘yxat yaratamiz. Aniq qilib aytadigan bo‘lsak, 15-3 shaklga o‘xshashdir:

<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />

<span class="caption">15-3-shakl: Ikkita ro'yxatlar, ya'ni `b` va `c` egalikni uchinchi ro'yxat, ya'ni `a`ga ulashishi</span>

Biz 5 va 10 dan iborat bo‘lgan `a` ro‘yxatni yaratamiz. Keyin yana ikkita ro‘yxatni ham yaratamiz, ya’ni 3dan boshlanadigan `b` va 4dan boshlanadigan `c`. `b` va `c` ro‘yxatlari 5 va 10dan iborat bo‘lgan `a` ro‘yxatda davom etadi. Boshqacha qilib aytganda, ro‘yxatlar birinchi 5 va 10dan iborat bo‘lgan birinchi ro‘yxat bilan ulashishadi.

15-17-ro‘yxatda ko‘rsatilgandek, bizning ssenariy bo‘yicha `Box<T>` bilan `List`dagi ta’rifimiz yordamida implement qilishga urunsak ishga tushmaydi:

<span class="filename">Fayl-nomi: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

<span class="caption">15-17-ro'yxat: Ko'rib turganimizdek, `Box<T>` yordamida uchunchi ro'yxatga ikkita ro'yxatni egaligini (ownership) ulashib bo'lmaydi </T></span>

Ushbu kodni kompilyatsiya qilsak, biz yuqoridagi xatolikni ko'ramiz:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

`Cons` variantlari o'zlariga tegishli bo'lgan ma'lumotlargagina egalik (own) qila oladi, shuninguchun biz `b` ro'yxatini yaratganimizda, `a` `b`ga o'tadi va `b` `a`ga egalik qiladi.Undan keyin, `c` ni yaratish uchun `a`dan foydalanmoqchi bo'lganizmizda bizga ruxsat bermaydi chunki `a` ko'chib ketganligi uchun.

Buning o'rniga havolalarni ushlab turish uchun `Cons` ta'rifini o'zgartirishimiz mumkin, lekin keyin biz layvtaym parametrlarini ko'rsatishimiz kerak bo'ladi. Layvtaym parametrlarini belgilash orqali, biz ro'yxatdagi har bir elementning yashashini ko'rsatamiz. 15-17 ro'yxatda ko'rsatilganidek bu elementlar va ro'yxatlarga tegishli, lekin har doim gam emas.

15-18-ro'yxatda ko'rsatilganidek, `Box<T>`ning o'rniga`Rc<T>`ni ishlatish uchun biz bizning `Ro'yxat`imizning mazmunini o'zgartiramiz. Har bir `Cons` varianti qiymatni o'zida ushlab turadi va `Rc<T>` `Ro'yxat`ni ko'rsatadi. `a`ning egaligini olishning o'rniga `b`ni yaratganimizda, `a` ni ushlab  turgan `Rc<List>`ni klonlaymiz, shu bilan birga referenslar sonini birdan ikkiga ko'paytiramiz va `Rc<List>`dagi ma'lumotlarning egaligini ulashish uchun `a` va `b`ga ruxsat beramiz. referenslar sonini ikkidan uchga ko'paytirgan holda, `c`ni yaratayotganimizda `a`ni ham klonlaymiz. `Rc::clone`ni har safar chaqirganimizda, `Rc<List>` tarkibidagi ma'lumotlarining referenslari soni oshiriladi, zero referenslar paydo bo'lmagungacha ma'lumotlar tozalanmaydi.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>

Biz scopeni ichiga `Rc<T>`ni kiritsh uchun `use` statementini qo'shishimiz kerak
chunki u muqaddimani ichida bo'lmagani uchun. `main`ni ichida 5 va 10ni saqlovch ro'yxatni
yaratamiz va uni `a`ga tegishli yangi `Rc<List>`ga joylashtiramiz. Keyin esa `b` va `c` yaratganimizda, `Rc::clone` funksiyasini chaqiramiz va argument sifatida `a`ga tegishli bo'lgan `Rc<List>`ga o'tkazib yuboramiz.

We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesn’t make a deep copy of all the data like most types’
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
`Rc::clone`.
`Rc::clone(&a)`ning o'rniga biz `a.clone()` chaqirishimiz mumkin edi, lekin Rust 
qoidalariga muofiq ushbu holatda `Rc::clone` ishlatgan ma'qul. `Rc:clone`ning implementatsiyasi `clone`ning ko'p implementatsiya turiga o'xshab ma'lumotlarni to'liq 
nusxa olmaydi.  

### Cloning an `Rc<T>` Increases the Reference Count

Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.

In Listing 15-19, we’ll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

<span class="caption">Listing 15-19: Printing the reference count</span>

At each point in the program where the reference count changes, we print the
reference count, which we get by calling the `Rc::strong_count` function. This
function is named `strong_count` rather than `count` because the `Rc<T>` type
also has a `weak_count`; we’ll see what `weak_count` is used for in the
[“Preventing Reference Cycles: Turning an `Rc<T>` into a
`Weak<T>`”][preventing-ref-cycles]<!-- ignore --> section.

This code prints the following:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

We can see that the `Rc<List>` in `a` has an initial reference count of 1; then
each time we call `clone`, the count goes up by 1. When `c` goes out of scope,
the count goes down by 1. We don’t have to call a function to decrease the
reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.

What we can’t see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely. Using `Rc<T>` allows a single value to have multiple owners, and
the count ensures that the value remains valid as long as any of the owners
still exist.

Via immutable references, `Rc<T>` allows you to share data between multiple
parts of your program for reading only. If `Rc<T>` allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the `RefCell<T>`
type that you can use in conjunction with an `Rc<T>` to work with this
immutability restriction.

[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
